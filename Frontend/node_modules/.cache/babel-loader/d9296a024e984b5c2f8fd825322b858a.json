{"ast":null,"code":"/* eslint-disable no-restricted-properties */\n\n/** normalize\n * This lets us translate a value from one scale to another.\n *\n * @param {Number} value - Our initial value to translate\n * @param {Number} min - the current minimum value possible\n * @param {Number} max - the current maximum value possible\n * @param {Number} scaleMin - the min value of the scale we're translating to\n * @param {Number} scaleMax - the max value of the scale we're translating to\n *\n * @returns {Number} the value on its new scale\n */\nexport var normalize = function normalize(_ref) {\n  var value = _ref.value,\n      min = _ref.min,\n      max = _ref.max,\n      _ref$scaleMin = _ref.scaleMin,\n      scaleMin = _ref$scaleMin === undefined ? 0 : _ref$scaleMin,\n      _ref$scaleMax = _ref.scaleMax,\n      scaleMax = _ref$scaleMax === undefined ? 1 : _ref$scaleMax; // If the `min` and `max` are the same value, it means our dataset is flat.\n  // For now, let's assume that flat data should be aligned to the bottom.\n\n  if (min === max) {\n    return scaleMin;\n  }\n\n  return scaleMin + (value - min) * (scaleMax - scaleMin) / (max - min);\n};\n/** moveTo\n * the coordinate that lies at a midpoint between 2 lines, based on the radius\n *\n * @param {Object} to - Our initial point\n * @param {Number} to.x - The x value of our initial point\n * @param {Number} to.y - The y value of our initial point\n * @param {Object} from - Our final point\n * @param {Number} from.x - The x value of our final point\n * @param {Number} from.y - The y value of our final point\n * @param {Number} radius - The distance away from the final point\n *\n * @returns {Object} an object holding the x/y coordinates of the midpoint.\n */\n\nexport var moveTo = function moveTo(to, from, radius) {\n  var vector = {\n    x: to.x - from.x,\n    y: to.y - from.y\n  };\n  var length = Math.sqrt(vector.x * vector.x + vector.y * vector.y);\n  var unitVector = {\n    x: vector.x / length,\n    y: vector.y / length\n  };\n  return {\n    x: from.x + unitVector.x * radius,\n    y: from.y + unitVector.y * radius\n  };\n};\n/** getDistanceBetween\n * Simple formula derived from pythagoras to calculate the distance between\n * 2 points on a plane.\n *\n * @param {Object} p1 - Our initial point\n * @param {Number} p1.x - The x value of our initial point\n * @param {Number} p1.y - The y value of our initial point\n * @param {Object} p2 - Our final point\n * @param {Number} p2.x - The x value of our final point\n * @param {Number} p2.y - The y value of our final point\n *\n * @returns {Number} the distance between the points.\n */\n\nexport var getDistanceBetween = function getDistanceBetween(p1, p2) {\n  return Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2));\n};\n/** checkForCollinearPoints\n * Figure out if the midpoint fits perfectly on a line between the two others.\n *\n * @param {Object} p1 - Our initial point\n * @param {Number} p1.x - The x value of our initial point\n * @param {Number} p1.y - The y value of our initial point\n * @param {Object} p2 - Our mid-point\n * @param {Number} p2.x - The x value of our mid-point\n * @param {Number} p2.y - The y value of our mid-point\n * @param {Object} p3 - Our final point\n * @param {Number} p3.x - The x value of our final point\n * @param {Number} p3.y - The y value of our final point\n\n * @returns {Boolean} whether or not p2 sits on the line between p1 and p3.\n */\n\nexport var checkForCollinearPoints = function checkForCollinearPoints(p1, p2, p3) {\n  return (p1.y - p2.y) * (p1.x - p3.x) === (p1.y - p3.y) * (p1.x - p2.x);\n};","map":{"version":3,"sources":["/Users/syoh/Desktop/Portfolio-App/Frontend/node_modules/react-trend/es/helpers/math.helpers.js"],"names":["normalize","_ref","value","min","max","_ref$scaleMin","scaleMin","undefined","_ref$scaleMax","scaleMax","moveTo","to","from","radius","vector","x","y","length","Math","sqrt","unitVector","getDistanceBetween","p1","p2","pow","checkForCollinearPoints","p3"],"mappings":"AAAA;;AAEA;;;;;;;;;;;AAWA,OAAO,IAAIA,SAAS,GAAG,SAASA,SAAT,CAAmBC,IAAnB,EAAyB;AAC9C,MAAIC,KAAK,GAAGD,IAAI,CAACC,KAAjB;AAAA,MACIC,GAAG,GAAGF,IAAI,CAACE,GADf;AAAA,MAEIC,GAAG,GAAGH,IAAI,CAACG,GAFf;AAAA,MAGIC,aAAa,GAAGJ,IAAI,CAACK,QAHzB;AAAA,MAIIA,QAAQ,GAAGD,aAAa,KAAKE,SAAlB,GAA8B,CAA9B,GAAkCF,aAJjD;AAAA,MAKIG,aAAa,GAAGP,IAAI,CAACQ,QALzB;AAAA,MAMIA,QAAQ,GAAGD,aAAa,KAAKD,SAAlB,GAA8B,CAA9B,GAAkCC,aANjD,CAD8C,CAS9C;AACA;;AACA,MAAIL,GAAG,KAAKC,GAAZ,EAAiB;AACf,WAAOE,QAAP;AACD;;AAED,SAAOA,QAAQ,GAAG,CAACJ,KAAK,GAAGC,GAAT,KAAiBM,QAAQ,GAAGH,QAA5B,KAAyCF,GAAG,GAAGD,GAA/C,CAAlB;AACD,CAhBM;AAkBP;;;;;;;;;;;;;;AAaA,OAAO,IAAIO,MAAM,GAAG,SAASA,MAAT,CAAgBC,EAAhB,EAAoBC,IAApB,EAA0BC,MAA1B,EAAkC;AACpD,MAAIC,MAAM,GAAG;AAAEC,IAAAA,CAAC,EAAEJ,EAAE,CAACI,CAAH,GAAOH,IAAI,CAACG,CAAjB;AAAoBC,IAAAA,CAAC,EAAEL,EAAE,CAACK,CAAH,GAAOJ,IAAI,CAACI;AAAnC,GAAb;AACA,MAAIC,MAAM,GAAGC,IAAI,CAACC,IAAL,CAAUL,MAAM,CAACC,CAAP,GAAWD,MAAM,CAACC,CAAlB,GAAsBD,MAAM,CAACE,CAAP,GAAWF,MAAM,CAACE,CAAlD,CAAb;AACA,MAAII,UAAU,GAAG;AAAEL,IAAAA,CAAC,EAAED,MAAM,CAACC,CAAP,GAAWE,MAAhB;AAAwBD,IAAAA,CAAC,EAAEF,MAAM,CAACE,CAAP,GAAWC;AAAtC,GAAjB;AAEA,SAAO;AACLF,IAAAA,CAAC,EAAEH,IAAI,CAACG,CAAL,GAASK,UAAU,CAACL,CAAX,GAAeF,MADtB;AAELG,IAAAA,CAAC,EAAEJ,IAAI,CAACI,CAAL,GAASI,UAAU,CAACJ,CAAX,GAAeH;AAFtB,GAAP;AAID,CATM;AAWP;;;;;;;;;;;;;;AAaA,OAAO,IAAIQ,kBAAkB,GAAG,SAASA,kBAAT,CAA4BC,EAA5B,EAAgCC,EAAhC,EAAoC;AAClE,SAAOL,IAAI,CAACC,IAAL,CAAUD,IAAI,CAACM,GAAL,CAASD,EAAE,CAACR,CAAH,GAAOO,EAAE,CAACP,CAAnB,EAAsB,CAAtB,IAA2BG,IAAI,CAACM,GAAL,CAASD,EAAE,CAACP,CAAH,GAAOM,EAAE,CAACN,CAAnB,EAAsB,CAAtB,CAArC,CAAP;AACD,CAFM;AAIP;;;;;;;;;;;;;;;;AAeA,OAAO,IAAIS,uBAAuB,GAAG,SAASA,uBAAT,CAAiCH,EAAjC,EAAqCC,EAArC,EAAyCG,EAAzC,EAA6C;AAChF,SAAO,CAACJ,EAAE,CAACN,CAAH,GAAOO,EAAE,CAACP,CAAX,KAAiBM,EAAE,CAACP,CAAH,GAAOW,EAAE,CAACX,CAA3B,MAAkC,CAACO,EAAE,CAACN,CAAH,GAAOU,EAAE,CAACV,CAAX,KAAiBM,EAAE,CAACP,CAAH,GAAOQ,EAAE,CAACR,CAA3B,CAAzC;AACD,CAFM","sourcesContent":["/* eslint-disable no-restricted-properties */\n\n/** normalize\n * This lets us translate a value from one scale to another.\n *\n * @param {Number} value - Our initial value to translate\n * @param {Number} min - the current minimum value possible\n * @param {Number} max - the current maximum value possible\n * @param {Number} scaleMin - the min value of the scale we're translating to\n * @param {Number} scaleMax - the max value of the scale we're translating to\n *\n * @returns {Number} the value on its new scale\n */\nexport var normalize = function normalize(_ref) {\n  var value = _ref.value,\n      min = _ref.min,\n      max = _ref.max,\n      _ref$scaleMin = _ref.scaleMin,\n      scaleMin = _ref$scaleMin === undefined ? 0 : _ref$scaleMin,\n      _ref$scaleMax = _ref.scaleMax,\n      scaleMax = _ref$scaleMax === undefined ? 1 : _ref$scaleMax;\n\n  // If the `min` and `max` are the same value, it means our dataset is flat.\n  // For now, let's assume that flat data should be aligned to the bottom.\n  if (min === max) {\n    return scaleMin;\n  }\n\n  return scaleMin + (value - min) * (scaleMax - scaleMin) / (max - min);\n};\n\n/** moveTo\n * the coordinate that lies at a midpoint between 2 lines, based on the radius\n *\n * @param {Object} to - Our initial point\n * @param {Number} to.x - The x value of our initial point\n * @param {Number} to.y - The y value of our initial point\n * @param {Object} from - Our final point\n * @param {Number} from.x - The x value of our final point\n * @param {Number} from.y - The y value of our final point\n * @param {Number} radius - The distance away from the final point\n *\n * @returns {Object} an object holding the x/y coordinates of the midpoint.\n */\nexport var moveTo = function moveTo(to, from, radius) {\n  var vector = { x: to.x - from.x, y: to.y - from.y };\n  var length = Math.sqrt(vector.x * vector.x + vector.y * vector.y);\n  var unitVector = { x: vector.x / length, y: vector.y / length };\n\n  return {\n    x: from.x + unitVector.x * radius,\n    y: from.y + unitVector.y * radius\n  };\n};\n\n/** getDistanceBetween\n * Simple formula derived from pythagoras to calculate the distance between\n * 2 points on a plane.\n *\n * @param {Object} p1 - Our initial point\n * @param {Number} p1.x - The x value of our initial point\n * @param {Number} p1.y - The y value of our initial point\n * @param {Object} p2 - Our final point\n * @param {Number} p2.x - The x value of our final point\n * @param {Number} p2.y - The y value of our final point\n *\n * @returns {Number} the distance between the points.\n */\nexport var getDistanceBetween = function getDistanceBetween(p1, p2) {\n  return Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2));\n};\n\n/** checkForCollinearPoints\n * Figure out if the midpoint fits perfectly on a line between the two others.\n *\n * @param {Object} p1 - Our initial point\n * @param {Number} p1.x - The x value of our initial point\n * @param {Number} p1.y - The y value of our initial point\n * @param {Object} p2 - Our mid-point\n * @param {Number} p2.x - The x value of our mid-point\n * @param {Number} p2.y - The y value of our mid-point\n * @param {Object} p3 - Our final point\n * @param {Number} p3.x - The x value of our final point\n * @param {Number} p3.y - The y value of our final point\n\n * @returns {Boolean} whether or not p2 sits on the line between p1 and p3.\n */\nexport var checkForCollinearPoints = function checkForCollinearPoints(p1, p2, p3) {\n  return (p1.y - p2.y) * (p1.x - p3.x) === (p1.y - p3.y) * (p1.x - p2.x);\n};"]},"metadata":{},"sourceType":"module"}