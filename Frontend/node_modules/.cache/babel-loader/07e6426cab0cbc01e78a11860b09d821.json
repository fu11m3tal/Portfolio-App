{"ast":null,"code":"import { normalize } from '../../helpers/math.helpers';\nexport var normalizeDataset = function normalizeDataset(data, _ref) {\n  var minX = _ref.minX,\n      maxX = _ref.maxX,\n      minY = _ref.minY,\n      maxY = _ref.maxY; // For the X axis, we want to normalize it based on its index in the array.\n  // For the Y axis, we want to normalize it based on the element's value.\n  //\n  // X axis is easy: just evenly-space each item in the array.\n  // For the Y axis, we first need to find the min and max of our array,\n  // and then normalize those values between 0 and 1.\n\n  var boundariesX = {\n    min: 0,\n    max: data.length - 1\n  };\n  var boundariesY = {\n    min: Math.min.apply(Math, data),\n    max: Math.max.apply(Math, data)\n  };\n  var normalizedData = data.map(function (point, index) {\n    return {\n      x: normalize({\n        value: index,\n        min: boundariesX.min,\n        max: boundariesX.max,\n        scaleMin: minX,\n        scaleMax: maxX\n      }),\n      y: normalize({\n        value: point,\n        min: boundariesY.min,\n        max: boundariesY.max,\n        scaleMin: minY,\n        scaleMax: maxY\n      })\n    };\n  }); // According to the SVG spec, paths with a height/width of `0` can't have\n  // linear gradients applied. This means that our lines are invisible when\n  // the dataset is flat (eg. [0, 0, 0, 0]).\n  //\n  // The hacky solution is to apply a very slight offset to the first point of\n  // the dataset. As ugly as it is, it's the best solution we can find (there\n  // are ways within the SVG spec of changing it, but not without causing\n  // breaking changes).\n\n  if (boundariesY.min === boundariesY.max) {\n    // eslint-disable-next-line no-param-reassign\n    normalizedData[0].y += 0.0001;\n  }\n\n  return normalizedData;\n};\nexport var generateAutoDrawCss = function generateAutoDrawCss(_ref2) {\n  var id = _ref2.id,\n      lineLength = _ref2.lineLength,\n      duration = _ref2.duration,\n      easing = _ref2.easing; // We do the animation using the dash array/offset trick\n  // https://css-tricks.com/svg-line-animation-works/\n\n  var autodrawKeyframeAnimation = '\\n    @keyframes react-trend-autodraw-' + id + ' {\\n      0% {\\n        stroke-dasharray: ' + lineLength + ';\\n        stroke-dashoffset: ' + lineLength + '\\n      }\\n      100% {\\n        stroke-dasharray: ' + lineLength + ';\\n        stroke-dashoffset: 0;\\n      }\\n      100% {\\n        stroke-dashoffset: \\'\\';\\n        stroke-dasharray: \\'\\';\\n      }\\n    }\\n  '; // One unfortunate side-effect of the auto-draw is that the line is\n  // actually 1 big dash, the same length as the line itself. If the\n  // line length changes (eg. radius change, new data), that dash won't\n  // be the same length anymore. We can fix that by removing those\n  // properties once the auto-draw is completed.\n\n  var cleanupKeyframeAnimation = '\\n    @keyframes react-trend-autodraw-cleanup-' + id + ' {\\n      to {\\n        stroke-dasharray: \\'\\';\\n        stroke-dashoffset: \\'\\';\\n      }\\n    }\\n  ';\n  return '\\n    ' + autodrawKeyframeAnimation + '\\n\\n    ' + cleanupKeyframeAnimation + '\\n\\n    #react-trend-' + id + ' {\\n      animation:\\n        react-trend-autodraw-' + id + ' ' + duration + 'ms ' + easing + ',\\n        react-trend-autodraw-cleanup-' + id + ' 1ms ' + duration + 'ms\\n      ;\\n    }\\n  ';\n};","map":{"version":3,"sources":["/Users/syoh/Desktop/Portfolio-App/Frontend/node_modules/react-trend/es/components/Trend/Trend.helpers.js"],"names":["normalize","normalizeDataset","data","_ref","minX","maxX","minY","maxY","boundariesX","min","max","length","boundariesY","Math","apply","normalizedData","map","point","index","x","value","scaleMin","scaleMax","y","generateAutoDrawCss","_ref2","id","lineLength","duration","easing","autodrawKeyframeAnimation","cleanupKeyframeAnimation"],"mappings":"AAAA,SAASA,SAAT,QAA0B,4BAA1B;AAEA,OAAO,IAAIC,gBAAgB,GAAG,SAASA,gBAAT,CAA0BC,IAA1B,EAAgCC,IAAhC,EAAsC;AAClE,MAAIC,IAAI,GAAGD,IAAI,CAACC,IAAhB;AAAA,MACIC,IAAI,GAAGF,IAAI,CAACE,IADhB;AAAA,MAEIC,IAAI,GAAGH,IAAI,CAACG,IAFhB;AAAA,MAGIC,IAAI,GAAGJ,IAAI,CAACI,IAHhB,CADkE,CAMlE;AACA;AACA;AACA;AACA;AACA;;AACA,MAAIC,WAAW,GAAG;AAAEC,IAAAA,GAAG,EAAE,CAAP;AAAUC,IAAAA,GAAG,EAAER,IAAI,CAACS,MAAL,GAAc;AAA7B,GAAlB;AACA,MAAIC,WAAW,GAAG;AAAEH,IAAAA,GAAG,EAAEI,IAAI,CAACJ,GAAL,CAASK,KAAT,CAAeD,IAAf,EAAqBX,IAArB,CAAP;AAAmCQ,IAAAA,GAAG,EAAEG,IAAI,CAACH,GAAL,CAASI,KAAT,CAAeD,IAAf,EAAqBX,IAArB;AAAxC,GAAlB;AAEA,MAAIa,cAAc,GAAGb,IAAI,CAACc,GAAL,CAAS,UAAUC,KAAV,EAAiBC,KAAjB,EAAwB;AACpD,WAAO;AACLC,MAAAA,CAAC,EAAEnB,SAAS,CAAC;AACXoB,QAAAA,KAAK,EAAEF,KADI;AAEXT,QAAAA,GAAG,EAAED,WAAW,CAACC,GAFN;AAGXC,QAAAA,GAAG,EAAEF,WAAW,CAACE,GAHN;AAIXW,QAAAA,QAAQ,EAAEjB,IAJC;AAKXkB,QAAAA,QAAQ,EAAEjB;AALC,OAAD,CADP;AAQLkB,MAAAA,CAAC,EAAEvB,SAAS,CAAC;AACXoB,QAAAA,KAAK,EAAEH,KADI;AAEXR,QAAAA,GAAG,EAAEG,WAAW,CAACH,GAFN;AAGXC,QAAAA,GAAG,EAAEE,WAAW,CAACF,GAHN;AAIXW,QAAAA,QAAQ,EAAEf,IAJC;AAKXgB,QAAAA,QAAQ,EAAEf;AALC,OAAD;AARP,KAAP;AAgBD,GAjBoB,CAArB,CAfkE,CAkClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,MAAIK,WAAW,CAACH,GAAZ,KAAoBG,WAAW,CAACF,GAApC,EAAyC;AACvC;AACAK,IAAAA,cAAc,CAAC,CAAD,CAAd,CAAkBQ,CAAlB,IAAuB,MAAvB;AACD;;AAED,SAAOR,cAAP;AACD,CAhDM;AAkDP,OAAO,IAAIS,mBAAmB,GAAG,SAASA,mBAAT,CAA6BC,KAA7B,EAAoC;AACnE,MAAIC,EAAE,GAAGD,KAAK,CAACC,EAAf;AAAA,MACIC,UAAU,GAAGF,KAAK,CAACE,UADvB;AAAA,MAEIC,QAAQ,GAAGH,KAAK,CAACG,QAFrB;AAAA,MAGIC,MAAM,GAAGJ,KAAK,CAACI,MAHnB,CADmE,CAMnE;AACA;;AACA,MAAIC,yBAAyB,GAAG,2CAA2CJ,EAA3C,GAAgD,4CAAhD,GAA+FC,UAA/F,GAA4G,gCAA5G,GAA+IA,UAA/I,GAA4J,qDAA5J,GAAoNA,UAApN,GAAiO,gJAAjQ,CARmE,CAUnE;AACA;AACA;AACA;AACA;;AACA,MAAII,wBAAwB,GAAG,mDAAmDL,EAAnD,GAAwD,uGAAvF;AAEA,SAAO,WAAWI,yBAAX,GAAuC,UAAvC,GAAoDC,wBAApD,GAA+E,uBAA/E,GAAyGL,EAAzG,GAA8G,qDAA9G,GAAsKA,EAAtK,GAA2K,GAA3K,GAAiLE,QAAjL,GAA4L,KAA5L,GAAoMC,MAApM,GAA6M,0CAA7M,GAA0PH,EAA1P,GAA+P,OAA/P,GAAyQE,QAAzQ,GAAoR,wBAA3R;AACD,CAlBM","sourcesContent":["import { normalize } from '../../helpers/math.helpers';\n\nexport var normalizeDataset = function normalizeDataset(data, _ref) {\n  var minX = _ref.minX,\n      maxX = _ref.maxX,\n      minY = _ref.minY,\n      maxY = _ref.maxY;\n\n  // For the X axis, we want to normalize it based on its index in the array.\n  // For the Y axis, we want to normalize it based on the element's value.\n  //\n  // X axis is easy: just evenly-space each item in the array.\n  // For the Y axis, we first need to find the min and max of our array,\n  // and then normalize those values between 0 and 1.\n  var boundariesX = { min: 0, max: data.length - 1 };\n  var boundariesY = { min: Math.min.apply(Math, data), max: Math.max.apply(Math, data) };\n\n  var normalizedData = data.map(function (point, index) {\n    return {\n      x: normalize({\n        value: index,\n        min: boundariesX.min,\n        max: boundariesX.max,\n        scaleMin: minX,\n        scaleMax: maxX\n      }),\n      y: normalize({\n        value: point,\n        min: boundariesY.min,\n        max: boundariesY.max,\n        scaleMin: minY,\n        scaleMax: maxY\n      })\n    };\n  });\n\n  // According to the SVG spec, paths with a height/width of `0` can't have\n  // linear gradients applied. This means that our lines are invisible when\n  // the dataset is flat (eg. [0, 0, 0, 0]).\n  //\n  // The hacky solution is to apply a very slight offset to the first point of\n  // the dataset. As ugly as it is, it's the best solution we can find (there\n  // are ways within the SVG spec of changing it, but not without causing\n  // breaking changes).\n  if (boundariesY.min === boundariesY.max) {\n    // eslint-disable-next-line no-param-reassign\n    normalizedData[0].y += 0.0001;\n  }\n\n  return normalizedData;\n};\n\nexport var generateAutoDrawCss = function generateAutoDrawCss(_ref2) {\n  var id = _ref2.id,\n      lineLength = _ref2.lineLength,\n      duration = _ref2.duration,\n      easing = _ref2.easing;\n\n  // We do the animation using the dash array/offset trick\n  // https://css-tricks.com/svg-line-animation-works/\n  var autodrawKeyframeAnimation = '\\n    @keyframes react-trend-autodraw-' + id + ' {\\n      0% {\\n        stroke-dasharray: ' + lineLength + ';\\n        stroke-dashoffset: ' + lineLength + '\\n      }\\n      100% {\\n        stroke-dasharray: ' + lineLength + ';\\n        stroke-dashoffset: 0;\\n      }\\n      100% {\\n        stroke-dashoffset: \\'\\';\\n        stroke-dasharray: \\'\\';\\n      }\\n    }\\n  ';\n\n  // One unfortunate side-effect of the auto-draw is that the line is\n  // actually 1 big dash, the same length as the line itself. If the\n  // line length changes (eg. radius change, new data), that dash won't\n  // be the same length anymore. We can fix that by removing those\n  // properties once the auto-draw is completed.\n  var cleanupKeyframeAnimation = '\\n    @keyframes react-trend-autodraw-cleanup-' + id + ' {\\n      to {\\n        stroke-dasharray: \\'\\';\\n        stroke-dashoffset: \\'\\';\\n      }\\n    }\\n  ';\n\n  return '\\n    ' + autodrawKeyframeAnimation + '\\n\\n    ' + cleanupKeyframeAnimation + '\\n\\n    #react-trend-' + id + ' {\\n      animation:\\n        react-trend-autodraw-' + id + ' ' + duration + 'ms ' + easing + ',\\n        react-trend-autodraw-cleanup-' + id + ' 1ms ' + duration + 'ms\\n      ;\\n    }\\n  ';\n};"]},"metadata":{},"sourceType":"module"}